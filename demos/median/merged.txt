
----client.html----

----client.js----
/**
 * Do not modify this file unless you have too
 * This file has UI handlers.
 */
// eslint-disable-next-line no-unused-vars
function connect() {
  $('#connectButton').prop('disabled', true);
  var computation_id = $('#computation_id').val();
  var party_count = parseInt($('#count').val());

  if (isNaN(party_count)) {
    $('#output').append(
      '<p>Invalid party count, please input a valid number!</p>'
    );
    $('#connectButton').prop('disabled', false);
  } else {
    var options = {
      party_count: party_count,
      decimal_digits: 5,
      integer_digits: 5,
      Zp: '32416190071',
    };
    options.onError = function (_, error) {
      $('#output').append('<p>' + error + '</p>');
    };
    options.onConnect = function () {
      $('#button').attr('disabled', false);
      $('#output').append('<p>All parties Connected!</p>');
    };

    var hostname = window.location.hostname.trim();
    var port = window.location.port;
    if (port == null || port === '') {
      port = '80';
    }
    if (!(hostname.startsWith('http://') || hostname.startsWith('https://'))) {
      hostname = 'http://' + hostname;
    }
    if (hostname.endsWith('/')) {
      hostname = hostname.substring(0, hostname.length - 1);
    }
    if (
      hostname.indexOf(':') > -1 &&
      hostname.lastIndexOf(':') > hostname.indexOf(':')
    ) {
      hostname = hostname.substring(0, hostname.lastIndexOf(':'));
    }

    hostname = hostname + ':' + port;
    // eslint-disable-next-line no-undef
    mpc.connect(hostname, computation_id, options);
  }
}

// eslint-disable-next-line no-unused-vars
function submit() {
  var input = parseFloat($('#number').val());

  if (isNaN(input)) {
    $('#output').append('<p>Invalid input, please input a valid number!</p>');
  } else if (100 < input || input < 0) {
    $('#output').append('<p>Invalid input, please input a number between 0 and 100!</p>'
    );
  } else {
    $('#button').attr('disabled', true);
    $('#output').append('<p>Starting...</p>');
    // eslint-disable-next-line no-undef
    var promise = mpc.compute(input);
    promise.then(handleResult);
  }
}

function handleResult(result) {
  $('#output').append('<p>Result is: ' + result.toString(10) + '</p>');
  $('#button').attr('disabled', false);
}

----mpc.js----
// mpc.js
(function (exports, node) {
  var saved_instance;

  exports.connect = function (hostname, computation_id, options) {
    var opt = Object.assign({}, options);
    opt.crypto_provider = true;

    if (node) {
      // eslint-disable-next-line no-undef
      JIFFClient = require('../../lib/jiff-client');
    }

    // eslint-disable-next-line no-undef
    saved_instance = new JIFFClient(hostname, computation_id, opt);
    return saved_instance;
  };

  // The MPC computation for median
  exports.compute = function (input, jiff_instance) {
    if (jiff_instance == null) {
      jiff_instance = saved_instance;
    }

    // Share the input
    var shares = jiff_instance.share(input);
    var allShares = Object.values(shares);

    // Implement secure sorting
    var sortedShares = secureSort(allShares, jiff_instance);

    // Compute the median
    var median = computeMedian(sortedShares, jiff_instance);

    // Return a promise to the final output
    return jiff_instance.open(median);
  };

  // Secure sorting function (simplified version for demonstration)
  function secureSort(sharesArray, jiff_instance) {
    // Using bubble sort for demonstration purposes
    console.log('sharesArray:', sharesArray);
    // console.log('Jiff Instance:', jiff_instance);
    let n = sharesArray.length;
    for (let i = 0; i < n - 1; i++) {
      for (let j = 0; j < n - i - 1; j++) {
        // Asynchronously compare two adjacent shares
        jiff_instance.SecretShare.prototype.sgt(sharesArray[j], sharesArray[j + 1]).then(function (isGreater) {
          if (isGreater) {
            // Swap the shares if necessary
            let temp = sharesArray[j];
            sharesArray[j] = sharesArray[j + 1];
            sharesArray[j + 1] = temp;
          }
        });
      }
    }

    // Return the sorted array of shares
    return sharesArray;
  }


  // Compute the median from sorted shares
  function computeMedian(sortedShares, jiff_instance) {
    var length = sortedShares.length;
    console.log('sortedShares:', sortedShares);
    console.log('length:', length);
    if (length % 2 === 1) {
      return sortedShares[Math.floor(length / 2)];
    } else {
      var mid1 = sortedShares[length / 2 - 1];
      var mid2 = sortedShares[length / 2];
      if (mid1 && mid2) {
        return mid1.sadd(mid2).sdiv(jiff_instance.share(2)[1]);
      } else {
        throw new Error('Mid1 or Mid2 is undefined');
      }
    }
  }
})(
  typeof exports === 'undefined' ? (this.mpc = {}) : exports,
  typeof exports !== 'undefined'
);

----party.js----
process.on('uncaughtException', function (err) {
  console.log('Uncaught Exception!');
  console.log(err);
  throw err;
});
process.on('unhandledRejection', function (reason) {
  console.log('Unhandled Rejection', reason);
});

/**
 * Do not change this unless you have to.
 * This code parses input command line arguments,
 * and calls the appropriate initialization and MPC protocol from ./mpc.js
 */

console.log(
  'Command line arguments: <input> [<party count> [<computation_id> [<party id>]]]]'
);

var mpc = require('./mpc');

// Read Command line arguments
var input = parseInt(process.argv[2], 10);

var party_count = process.argv[3];
if (party_count == null) {
  party_count = 2;
} else {
  party_count = parseInt(party_count);
}

var computation_id = process.argv[4];
if (computation_id == null) {
  computation_id = 'test';
}

var party_id = process.argv[5];
if (party_id != null) {
  party_id = parseInt(party_id, 10);
}

// JIFF options
var options = { party_count: party_count, party_id: party_id };
options.onConnect = function (jiff_instance) {
  var promise = mpc.compute(input);

  promise.then(function (v) {
    console.log(v);
    jiff_instance.disconnect(true, true);
  });
};

// Connect
mpc.connect('http://localhost:8080', computation_id, options);

----server.js----
var path = require('path');
var express = require('express');
var app = express();
var http = require('http').Server(app);

//Serve static files
//Configure App
app.use('/demos', express.static(path.join(__dirname, '..', '..', 'demos')));
app.use('/dist', express.static(path.join(__dirname, '..', '..', 'dist')));
app.use('/lib/ext', express.static(path.join(__dirname, '..', '..', 'lib', 'ext')));

var JIFFServer = require('../../lib/jiff-server.js');
new JIFFServer(http, { logs: true });

// Serve static files.
http.listen(8080, function () {
  console.log('listening on *:8080');
});

console.log('Direct your browser to http://localhost:8080/demos/median/client.html.');
console.log('To run a node.js based party: node demos/median/party <input>');
console.log();

----test.js----
// const http = require('http');
// const assert = require('assert');
const { fork } = require('child_process');
const path = require('path');

// Configuration
// const PORT = 8080;
// const HOST = 'localhost';

// Start the server
const serverProcess = fork(path.join(__dirname, 'server.js'));

// Delay function for asynchronous operations
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// Test function
async function runTest() {
  try {
    // Wait for the server to start
    await delay(5000);

    // Simulate client behavior
    const input = 50; // example input
    const clientProcess = fork(path.join(__dirname, 'party.js'), [input.toString()]);
    // Wait for client to finish computation
    await new Promise((resolve, reject) => {
      clientProcess.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error('Client process exited with code ' + code));
        }
      });
    });

    // Test expected results (modify according to your logic)
    // Example: assert.strictEqual(receivedResult, expectedResult, 'The MPC result is incorrect');



    console.log('Test passed: MPC computation is correct.');
  } catch (error) {
    console.error('Test failed:', error.message);
  } finally {
    // Cleanup
    serverProcess.kill();
  }
}

// Run the test
runTest();

