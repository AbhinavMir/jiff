/**
 * Send a custom message to a subset of parties.
 * @memberof jiff-instance
 * @function emit
 * @instance
 * @param {string} tag - the tag to attach to the message.
 * @param {Array} receivers - contains the party ids to receive the message, all non-server parties if null.
 * @param {string} message - the message to send.
 * @param {boolean} [encrypt=true] - if true, messages will be encrypted.
 */
jiff.emit = function (tag, receivers, message, encrypt) {
  if (typeof(message) !== 'string') {
    throw new Error('Emit: message must be a string');
  }

  if (receivers == null) {
    receivers = [];
    for (var i = 1; i <= jiff.party_count; i++) {
      receivers.push(i);
    }
  } else {
    receivers = receivers.slice();
  }

  // Remove own index from receivers
  var index = receivers.indexOf(jiff.id);
  if (index > -1) {
    receive_custom(jiff, { tag: tag, party_id: jiff.id, message: message, encrypted: false });
  }

  for (var p = 0; p < receivers.length; p++) {
    if (receivers[p] === jiff.id) {
      continue;
    }

    var message_to_send = { tag: tag, party_id: receivers[p], message: message, encrypted: encrypt };
    message_to_send = jiff.execute_array_hooks('beforeOperation', [jiff, 'custom', message_to_send], 2);

    if (message_to_send['encrypted'] !== false) {
      message_to_send['message'] = jiff.hooks.encryptSign(jiff, message_to_send['message'], jiff.keymap[message_to_send['party_id']], jiff.secret_key);
      message_to_send['encrypted'] = true;
    }

    jiff.socket.safe_emit('custom', JSON.stringify(message_to_send));
  }
};

/**
 * Registers the given function as a listener for messages with the given tag.
 * Removes any previously set listener for this tag.
 * @memberof jiff-instance
 * @function listen
 * @instance
 * @param {string} tag - the tag to listen for.
 * @param {function(party_id, string)} handler - the function that handles the received message: takes the sender id and the message as parameters.
 */
jiff.listen = function (tag, handler) {
  jiff.listeners[tag] = handler;

  var stored_messages = jiff.custom_messages_mailbox[tag];
  if (stored_messages == null) {
    return;
  }

  for (var i = 0; i < stored_messages.length; i++) {
    var sender_id = stored_messages[i].sender_id;
    var message = stored_messages[i].message;
    handler(sender_id, message);
  }

  delete jiff.custom_messages_mailbox[tag];
};

/**
 * Removes the custom message listener attached to the given tag.
 * @param {string} tag - the tag of the listener to remove.
 */
jiff.remove_listener = function (tag) {
  delete jiff.listeners[tag];
};




/**
 * Requests secret(s) from the server (crypto provider) of type matching the given label.
 * @param {jiff-instance} jiff - the jiff instance.
 * @param {string} label - the type of secret(s) being requested from crypto_provider (e.g. triplet, bit, etc)
 * @param {Array} [receivers_list=all_parties] - array of party ids that want to receive the secret(s), by default, this includes all parties.
 * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret(s).
 * @param {number} [Zp=jiff_instance.Zp] - the mod, defaults to the Zp of the instance.
 * @param {string} [op_id=auto_Gen()] - an id which is used to identify the secret requested, so that every party
 *                              gets a share from the same secret for every matching instruction. An automatic id
 *                              is generated by increasing a local counter per label, default ids suffice when all
 *                              parties execute all instructions in the same order.
 * @param {object} [params={}] - any additional parameters specific to the label, these are defined by the label handler at the server side.
 *                               some of these parameters may be optional, while others may be required.
 * @returns {promise} a promise to the secret(s) provided by the server/crypto provider, the promise returns an object with the given format:
 *                               { values: <any values returned by the server side>, shares: <array of secret share objects matching shares returned by server by index>}
 */
function from_crypto_provider(jiff, label, receivers_list, threshold, Zp, op_id, params) {
  // defaults
  if (Zp == null) {
    Zp = jiff.Zp;
  }
  if (receivers_list == null) {
    receivers_list = [];
    for (var i = 1; i <= jiff.party_count; i++) {
      receivers_list.push(i);
    }
  }
  if (threshold == null) {
    threshold = receivers_list.length;
  }
  if (op_id == null) {
    op_id = jiff.counters.gen_op_id('crypto_provider:' + label, receivers_list);
  }
  if (params == null) {
    params = {};
  }

  // Send a request to the server
  var msg = { label: label, op_id: op_id, receivers: receivers_list, threshold: threshold, Zp: Zp, params: params };
  msg = jiff.execute_array_hooks('beforeOperation', [jiff, 'crypto_provider', msg], 2);
  msg = JSON.stringify(msg);

  // Setup deferred to handle receiving the result later.
  jiff.deferreds[op_id] = new jiff.helpers.Deferred;
  var result = jiff.deferreds[op_id].promise;

  // send a request to the server.
  jiff.socket.safe_emit('crypto_provider', msg);
  return result;
}









/**
 * Wait until the public keys of these parties are known.
 * The public keys may be known before the parties connect (if provided in the options),
 * or they could be sent by the server after the parties connect.
 * Computation specified in the callback may assume that these parties are connected,
 * if they are not, the server will handle storing and relaying the needed messages
 * to them when they connect.
 * @memberof jiff-instance
 * @instance
 * @param {Array} parties - an array of party ids to wait for, must explicitly include 's1' if callback must wait for the server.
 * @param {function(jiff-instance)} callback - the function to execute when these parties are known.
 * @param {boolean} [wait_for_initialization=true] - specifies whether to wait for initialization to be complete
 *                                                   before executing the callback (even if parties are available).
 *                                                   Set this to false if you do not need the party count and this
 *                                                   party's id, or if you already have them, and you are certain
 *                                                   they will be accepted by the server on initialization.
 */
jiff.wait_for = function (parties, callback, wait_for_initialization) {
  if (wait_for_initialization == null) {
    wait_for_initialization = true;
  }

  jiff.wait_callbacks.push({parties: parties, callback: callback, initialization: wait_for_initialization});
  jiff.execute_wait_callbacks(); // See if the callback can be executed immediately
};


/**
 * Share a secret input.
 * @method share
 * @memberof jiff-instance
 * @instance
 * @param {number} secret - the number to share (this party's input).
 * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
 * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
 * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
 * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
 * @param {string|number} [share_id=auto_gen()] - the tag used to tag the messages sent by this share operation, this tag is used
 *                                   so that parties distinguish messages belonging to this share operation from other
 *                                   share operations between the same parties (when the order of execution is not
 *                                   deterministic). An automatic id is generated by increasing a local counter, default
 *                                   ids suffice when all parties execute all sharing operations with the same senders
 *                                   and receivers in the same order.
 * @returns {object} a map (of size equal to the number of sending parties)
 *          where the key is the party id (from 1 to n)
 *          and the value is the share object that wraps
 *          the value sent from that party (the internal value maybe deferred).
 * @example
 * // share an input value with all parties, and receive all other parties' inputs
 * var shares = jiff_instance.share(input);
 * // my party id is '1', so the first share is mine (technically my share of my input value)
 * var my_share = shares[1];
 *
 * // my share of party 2's input
 * var p2_share = shares[2];
 */
jiff.share = function (secret, threshold, receivers_list, senders_list, Zp, share_id) {
  // type check to confirm the secret to be shared is a number
  // for fixed-point extension it should allow non-ints
  if (secret != null && (typeof(secret) !== 'number' || Math.floor(secret) !== secret || secret < 0)) {
    throw new Error('secret must be a non-negative whole number');
  }
  if (secret != null && (secret >= (Zp == null ? jiff.Zp : Zp))) {
    throw new Error('secret must fit inside Zp');
  }
  return jiff.internal_share(secret, threshold, receivers_list, senders_list, Zp, share_id);
};

/**
 * Same as jiff-instance.share, but used by internal JIFF primitives/protocols (bgw).
 */
jiff.internal_share = function (secret, threshold, receivers_list, senders_list, Zp, share_id) {
  return jiff_share(jiff, secret, threshold, receivers_list, senders_list, Zp, share_id);
};

/**
 * Share an array of values. Each sender may have an array of different length. This is handled by the lengths parameter.
 * This function will reveal the lengths of the shared array.
 * If parties would like to keep the lengths of their arrays secret, they should agree on some "max" length apriori (either under MPC
 * or as part of the logistics of the computation), all their arrays should be padded to that length by using appropriate default/identity
 * values.
 * @method share_array
 * @memberof jiff-instance
 * @instance
 * @param {Array} array - the array to be shared.
 * @param {null|number|object} [lengths] - the lengths of the arrays to be shared, has the following options: <br>
 *                                       1. null: lengths are unknown, each sender will publicly reveal the lengths of its own array. <br>
 *                                       2. number: all arrays are of this length <br>
 *                                       3. object: { <sender_party_id>: length }: must specify the length of the array for each sender. <br>
 * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
 * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
 * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
 * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
 * @param {string|number} [share_id=auto_gen()] - the base tag used to tag the messages sent by this share operation, every element of the array
 *                                   will get a unique id based on the concatenation of base_share_id and the index of the element.
 *                                   This tag is used so that parties distinguish messages belonging to this share operation from
 *                                   other share operations between the same parties (when the order of execution is not
 *                                   deterministic). An automatic id is generated by increasing a local counter, default
 *                                   ids suffice when all parties execute all sharing operations with the same senders
 *                                   and receivers in the same order.
 * @returns {promise} if the calling party is a receiver then a promise to the shared arrays is returned, the promise will provide an object
 *                    formatted as follows: { <party_id>: [ <1st_share>, <2nd_share>, ..., <(lengths[party_id])th_share> ] }
 *                    where the party_ids are those of the senders.
 *                    if the calling party is not a receiver, then null is returned.
 */
jiff.share_array = function (array, lengths, threshold, receivers_list, senders_list, Zp, share_id) {
  return jiff_share_array(jiff, array, lengths, threshold, receivers_list, senders_list, Zp, share_id);
};

/**
 * Open a secret share to reconstruct secret.
 * @method open
 * @memberof jiff-instance
 * @instance
 * @param {SecretShare} share - this party's share of the secret to reconstruct.
 * @param {Array} [parties=all_parties] - an array with party ids (1 to n) of receiving parties.
 * @param {string|number} [op_id=auto_gen()] - the operation id to be used to tag outgoing messages.
 * @returns {promise|null} a (JQuery) promise to the open value of the secret, null if the party is not specified in the parties array as a receiver.
 * @throws error if share does not belong to the passed jiff instance.
 * @example
 * var shares = jiff_instance.share(input);
 * //multiply the inputs of party 1 and 2 together
 * var result = shares[1].mult(shares[2]);
 * // reveal the result of the multiplication to all parties
 * return jiff_instance.open(result);
 */
jiff.open = function (share, parties, op_id) {
  return jiff.internal_open(share, parties, op_id);
};

/**
 * Same as jiff-instance.open, but used by internal JIFF primitives/protocols (comparisons and secret multiplication).
 */
jiff.internal_open = function (share, parties, op_id) {
  return jiff_open(jiff, share, parties, op_id);
};

/**
 * Opens an array of secret shares.
 * @method open_array
 * @memberof jiff-instance
 * @instance
 * @param {SecretShare[]} shares - an array containing this party's shares of the secrets to reconstruct.
 * @param {Array} [parties=all_parties] - an array with party ids (1 to n) of receiving parties.
 * @param {string|number} [op_id=auto_gen()] - same as jiff_instance.open
 * @returns {promise} a (JQuery) promise to ALL the open values of the secret, the promise will yield
 *                    an array of values matching the corresponding given secret share by index.
 * @throws error if some shares does not belong to the passed jiff instance.
 */
jiff.open_array = function (shares, parties, op_id) {
  return jiff_open_array(jiff, shares, parties, op_id);
};

/**
 * Receive shares from the specified parties and reconstruct their secret.
 * Use this function in a party that will receive some answer/value but does not have a share of it.
 * @method receive_open
 * @memberof jiff-instance
 * @instance
 * @param {Array} senders - an array with party ids (1 to n) specifying the parties sending the shares.
 * @param {Array} [receivers=all_parties] - an array with party ids (1 to n) specifying the parties receiving the result.
 * @param {number} [threshold=senders.length] - the min number of parties needed to reconstruct the secret, defaults to all the senders.
 * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
 * @param {string|number} [op_id=auto_Gen()] - same as jiff-instance.open
 * @returns {promise} a (JQuery) promise to the open value of the secret.
 */
jiff.receive_open = function (senders, receivers, threshold, Zp, op_id) {
  if (senders == null) {
    throw new Error('Must provide "senders" parameter in receive_open');
  }
  if (Zp == null) {
    Zp = jiff.Zp;
  }
  return jiff_open(jiff, jiff.secret_share(jiff, true, null, null, senders, (threshold == null ? senders.length : threshold), Zp), receivers, op_id);
};

/**
 * Requests secret(s) from the server (crypto provider) of type matching the given label.
 * @method from_crypto_provider
 * @memberof jiff-instance
 * @instance
 * @param {string} label - the type of secret(s) being requested from crypto_provider (e.g. triplet, bit, etc)
 * @param {Array} [receivers_list=all_parties] - array of party ids that want to receive the secret(s), by default, this includes all parties.
 * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret(s).
 * @param {number} [Zp=jiff_instance.Zp] - the mod, defaults to the Zp of the instance.
 * @param {string} [op_id=auto_Gen()] - an id which is used to identify the secret requested, so that every party
 *                              gets a share from the same secret for every matching instruction. An automatic id
 *                              is generated by increasing a local counter per label, default ids suffice when all
 *                              parties execute all instructions in the same order.
 * @returns {promise} a promise to the secret(s) provided by the server/crypto provider, the promise returns an object with the given format:
 *                               { values: <any values returned by the server side>, shares: <array of secret share objects matching shares returned by server by index>}
 */
jiff.from_crypto_provider = function (label, receivers_list, threshold, Zp, op_id, params) {
  return from_crypto_provider(jiff, label, receivers_list, threshold, Zp, op_id, params);
};

// also add custom emit and listen and remove listeners




/**
 * Starts a new barrier, all promises and secret shares created between this call and the corresponding start_barrier
 * call will be part of this barrier. start_barrier may be called before previous barriers are resolved, in which
 * case promises / secret shares created will be part of the new barrier as well as any previous barriers.
 * @returns {number} a barrier id that identifies this barrier.
 */
jiff.start_barrier = function () {
  jiff.barriers.push([]);
  return jiff.barriers.length - 1;
};

/**
 * Adds given promise to all active barriers.
 * @param {promise} promise - the promise to add.
 */
jiff.add_to_barriers = function (promise) {
  for (var i = 0; i < jiff.barriers.length; i++) {
    jiff.barriers[i].push(promise);
  }
};

/**
 * Executes the callback only after all promises / secret shares in the barrier were resolved.
 * @param {number} [barrier_id=jiff.barriers.length - 1] - identifies the barrier, should be returned by start_barrier.
 *                                                         by default, barrier_id will refer to the last barrier.
 * @returns {promise} a promise that resolves after the secret shares are resolved.
 */
jiff.end_barrier = function (barrier_id) {
  var barrier;
  if (barrier_id == null) {
    barrier = jiff.barriers.pop();
  } else {
    barrier = jiff.barriers[barrier_id];
    jiff.barriers.splice(barrier_id, 1);
  }

  return Promise.all(barrier);
};

/**
 * Disconnects from the computation.
 * Allows the client program to exit.
 * @method disconnect
 * @memberof jiff-instance
 * @instance
 * @param {boolean} [safe=false] - if true, jiff will disconnect safely (i.e. after ensuring all
 *                                 outgoing pending messages were delivered).
 * @param {boolean} [free=false] - if set to true, it means this party's disconnection is final, and all resources
 *                                 associated with this party must be freed.
 *                                 If all parties in a computation are freed, then all resources associated with the
 *                                 computation are freed, and any subsequent reconnection to the computation is as
 *                                 if a the connection is for a fresh new computation.
 * @param {function()} [callback] - executed after the instance safely disconnects, if safe is set to false, this
 *                                  parameter is ignored.
 */
jiff.disconnect = function (safe, free, callback) {
  if (safe) {
    jiff.socket.safe_disconnect(free, callback);
  } else {
    if (free) {
      jiff.free();
    }
    jiff.socket.disconnect();
  }
};

/**
 * Emits event to free up all the resources allocated for this party on the server.
 * Best not to call this function directly, as it can break things if resources still need to be used.
 * Instead, use jiff.disconnect(safe, free, callback) to free after safely disconnecting.
 * @param {io.socket} socket - the socket through which to free.
 */
jiff.free = function () {
  var msg = jiff.execute_array_hooks('beforeOperation', [jiff, 'free', {}], 2);
  if (options.__internal_socket == null) {
    jiff.socket.safe_emit('free', JSON.stringify(msg));
  } else {
    jiff.execute_array_hooks('afterOperation', [jiff, 'free', msg], 2);
  }
};